---
layout: default
title: ace learning.
excerpt: ace learning.
tags: [ace, c++, network, patterns]
---

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">高级ACE向导</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">目录</h3>
<div class="outline-text-3" id="text-1-1">

<ol>
<li>简述面向对象网络通信和并发的概念，以及系统平台的机制；
<ul>
<li>Emphasis是建立在实际解决方安上的。
</li>
</ul>

</li>
<li>一系列的详细实例讲解
<ul>
<li>网络日志服务
</li>
<li>支持并发的web服务器
</li>
<li>应用层的电信网关
</li>
<li>呼叫中心管理者事件服务
</li>
</ul>

</li>
<li>常见并发编程策略
</li>
<li>其他深入学习资源链接
</li>
</ol>


</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">软件开发环境</h3>
<div class="outline-text-3" id="text-1-2">

<ol>
<li>本文讨论的内容很大程度上是独立与网络，操作系统，编程语言的。
</li>
</ol>

<p>:: 目前是成功应用在c++编写的tcp/ip网络上的unix/posix，windows，RTOS 平台上。
</p><ol>
<li>文中的案例完全使用完全ACE OO框架组件进行说明的。
</li>
</ol>

<p>:: 尽管ACE 是使用C++语言编写的，但本文中包含的规则是可以应用到其他OOprinciples语言的。
:: e.g., Java, Eiffel, Smalltalk, etc.
</p><ol>
<li>另外，在其他的网络和背板串行(backplanes)通信系统中,也同样可以使用。
</li>
</ol>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">复杂性由来</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">固有复杂性</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>– Latency 延迟
– Reliability 可靠性
– Synchronization 同步
– Deadlock 死锁 
</p></div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">偶发复杂性</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>– Low-level APIs 地层次的API
– Poor debugging tools 差劲的调试工具
– Algorithmic decomposition 算法分解
– Continuous re-invention 持续改进
</p></div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">固有复杂性源头</h4>
<div class="outline-text-4" id="text-1-3-3">


</div>

<div id="outline-container-1-3-3-1" class="outline-5">
<h5 id="sec-1-3-3-1">并发编程</h5>
<div class="outline-text-5" id="text-1-3-3-1">

<ul>
<li>排除竞争条件
</li>
<li>死锁规避
</li>
<li>合理的任务调度
</li>
<li>性能的最优化和调节
</li>
</ul>

</div>

</div>

<div id="outline-container-1-3-3-2" class="outline-5">
<h5 id="sec-1-3-3-2">分布式编程</h5>
<div class="outline-text-5" id="text-1-3-3-2">

<ul>
<li>处理延迟的影响
</li>
<li>容错能力及高可靠性
</li>
<li>负载均衡及服务的细化
</li>
<li>分布式事件顺序一致
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">偶发复杂性的来源</h4>
<div class="outline-text-4" id="text-1-3-4">

<p>偶发复杂性主要源于用于开发并发应用程序的工具和技术的缺乏，例如：
</p><ul>
<li>缺乏便携式，折返(reentrant)，类型安全的、可扩展的系统调用接口和组件库
</li>
<li>不完善的调试支持及并发和分布式程序的分析工具
</li>
<li>广泛使用的算法分解
</li>
</ul>

<p>:: 对于解释并发编程的概念和算法是有很好的，但真正实现并发的网络程序是困难和不足的。
</p><ul>
<li>持续的重新发现和核心概念和组件的再造
</li>
</ul>

</div>

</div>

<div id="outline-container-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">OO 方法对并发和分布式应用的贡献</h4>
<div class="outline-text-4" id="text-1-3-5">


</div>

<div id="outline-container-1-3-5-1" class="outline-5">
<h5 id="sec-1-3-5-1">网络并发编程传统方法为使用OS 底层的机制，如：</h5>
<div class="outline-text-5" id="text-1-3-5-1">

<ul>
<li>fork/exec 进程调用
</li>
<li>Shared memory and semaphores 共享内存和信号
</li>
<li>Memory-mapped files 内存映射文件
</li>
<li>Signals 信号
</li>
<li>sockets/select 套节字和select 模型
</li>
<li>Low-level thread APIs 底层线程API
</li>
</ul>

</div>

</div>

<div id="outline-container-1-3-5-2" class="outline-5">
<h5 id="sec-1-3-5-2">模式和框架提升程序开发层次集中到和应用相关的内容上，如：</h5>
<div class="outline-text-5" id="text-1-3-5-2">

<ul>
<li>服务的功能和策略
</li>
<li>服务的配置
</li>
<li>并发事件的多路解码(demultiplexing)以及事件处理器调度
</li>
<li>服务的并发和同步
</li>
</ul>



</div>
</div>

</div>

<div id="outline-container-1-3-6" class="outline-4">
<h4 id="sec-1-3-6">模式总览</h4>
<div class="outline-text-4" id="text-1-3-6">


</div>

<div id="outline-container-1-3-6-1" class="outline-5">
<h5 id="sec-1-3-6-1">模式指的是用于一个特定的条件或上下文环境下开发软件所使用的解决问题的方安</h5>
<div class="outline-text-5" id="text-1-3-6-1">

<p>:: i.e., “Patterns == problem/solution pairs within a context”
</p>

</div>
</div>
</div>
</div>
</div>
